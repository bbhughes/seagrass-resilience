# Bayesian analysis of seagrass stressors 

```{r, echo=FALSE}
library(knitr)
opts_knit$set(root.dir = "..") 
```

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r, message=FALSE}
library(tidyverse)
library(rstanarm)
library(RColorBrewer)
library(assertthat)
```

We'll create this folder in case it isn't already there. 

```{r}
dir.create("figs", showWarnings = FALSE)
dir.create("data/generated", showWarnings = FALSE)
```

A custom theme for ggplot:

```{r}
theme_gg <- function(base_size = 11, base_family = "") {
  theme_light() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      strip.background = element_rect(fill = NA, colour = NA),
      strip.text.x = element_text(colour = "grey10"),
      axis.text = element_text(colour = "grey30"),
      axis.title = element_text(colour = "grey30"),
      legend.title = element_text(colour = "grey30", size = rel(0.9)),
      panel.border = element_rect(fill = NA, colour = "grey70", size = 1),
      legend.key.size = unit(0.8, "lines"),
      legend.text = element_text(size = rel(0.7), colour = "grey30"),
      legend.key = element_rect(colour = NA)
    )
}
```

Let's read in the data and select only the columns we want to use:

```{r}
d <- read_csv("data/Mesocosm_ExperimentalData_R.csv", na = c("NA", "na"))
d <- mutate(d, id = as.character(pH))
names(d) <- tolower(names(d))
sd_ph <- sd(d$ph)
mean_ph <- mean(d$ph)
scale_ph <- function(x) (x - mean_ph) / (2 * sd_ph)

d$ph_scaled <- scale_ph(d$ph)
d$ph_scaled2 <- d$ph_scaled^2
sd_ph2 <- sd(d$ph_scaled2)
scale_ph2 <- function(x) x / (2 * sd_ph2)
d$ph_scaled2 <- scale_ph2(d$ph_scaled^2)
d$nutrients_scaled <- arm::rescale(d$nutrients)
d$nutrients <- as.numeric(as.factor(d$nutrients)) - 1
d$ulva_grazing <- d$ulva_grazing + 0.1 # TODO fix

d_log <- select(d, 
  ph,
  ph_scaled,
  ph_scaled2,
  nutrients,
  epiphyte_cm_shoot,
  algal_mass_g_dw,
  rhi_mass_g_dw_mean,
  change_idotea_mass_g_fw,
  change_seahare_mass_g_fw,
  sht_g_dw_mean,
  rhi_mass_g_dw_mean,
  rhi_elong_cm,
  ido_mortality,
  sh_grazing,
  ulva_grazing,
  dead_shoots,
  sh_mortality)
saveRDS(d_log, file = "data/generated/data-clean.rds")

d_mixed <- read_csv("data/mesocosm_rawdata_R.csv", na = c("NA", "na"))
names(d_mixed) <- tolower(names(d_mixed))
d_mixed <- mutate(d_mixed, id = paste(paste(rep, ph, sep = "-"), nutrients, sep = "-"))
d_mixed <- mutate(d_mixed, tank = paste(nutrients, ph, sep = "-"))

d2 <- d_mixed %>% select(tank, id, rep, ph, nutrients, shoot_length, sht_g_dw, rhi_mass_g_dw,
  rhi_elong_cm) %>% 
  gather(response, value, -id, -rep, -nutrients, -ph, -tank)
d2$nutrients <- as.numeric(as.factor(d2$nutrients)) - 1

d3 <- d_mixed %>% select(tank, id, rep, ph1, nutrients1, 
  sh_grazing, ulva_grazing, diatom_grazing, epiphyte_grazing) %>%
  filter(nutrients1 != "")
d3$ulva_grazing <- d3$ulva_grazing + 0.1 # TODO fix
d3$epiphyte_grazing <- d3$epiphyte_grazing + 0.1 # TODO fix?
d3$sh_grazing <- d3$sh_grazing + 0.1 # TODO fix?
d3 <- d3 %>% gather(response, value, -id, -rep, -nutrients1, -ph1, -tank)
d3$nutrients1 <- as.numeric(as.factor(d3$nutrients1)) - 1
d3 <- rename(d3, ph = ph1, nutrients = nutrients1) %>% 
  select(-tank, -id, -rep)

ggplot(d2, aes(ph, log(value), colour = as.factor(nutrients))) + 
  geom_point(position = position_jitter(width = 0.03), alpha = 0.5) +
  facet_wrap(~response, scales = "free_y") +
  theme_gg()

options(mc.cores = parallel::detectCores())

d2 <- mutate(d2, ph_scaled = scale_ph(ph))
d2 <- mutate(d2, ph_scaled2 = scale_ph2(ph_scaled^2))
```

Poly?

```{r}
dd <- filter(d_log, nutrients == 1);x <- poly(dd$ph_scaled, 2);par(mfrow = c(3,1));plot(x[,1], type = "l");lines(x[,2]);plot(dd$ph_scaled, type = "l");lines(dd$ph_scaled^2)


x <- dd$ph_scaled
x2 <- arm::rescale(x^2)
plot(x, type = "l");lines(x2)

sd(x)
sd(x2)

dd <- d_log
x <- dd$ph_scaled
x2 <- arm::rescale(x^2)

m1 <- lm(log(algal_mass_g_dw) ~ ph_scaled, data = dd)
m2 <- lm(log(algal_mass_g_dw) ~ poly(ph_scaled, 2), data = dd)
m3 <- lm(log(algal_mass_g_dw) ~ ph_scaled + x2, data = dd)
m4 <- lm(log(algal_mass_g_dw) ~ ph_scaled + x2 + nutrients, data = dd)

coef(m1)
coef(m2)
coef(m3)

broom::tidy(m1)
broom::tidy(m2)
broom::tidy(m3)
broom::tidy(m4)
```


It's probably best if we model this without any random intercepts by tanks. We don't have repeated observations at multiple tanks for a given treatment level. So, a lot of the systematic variation across treatment levels is likely to get absorbed into the spread of the random intercept deviations. 

```{r}
m2 <- stan_lmer(log(value) ~ poly(ph_scaled, 2) + nutrients + (1|tank),
  data = filter(d2, response == "sht_g_dw"), iter = 400)
plot(m2)

m3 <- stan_glm(log(value) ~ poly(ph_scaled, 2) + nutrients,
  data = filter(d2, response == "sht_g_dw"), iter = 400)
plot(m3)

m4 <- stan_glm(log(sht_g_dw_mean) ~ poly(ph_scaled, 2) + nutrients,
  data = d_log, iter = 400)
plot(m4)

############

m2 <- stan_lmer(log(value) ~ poly(ph_scaled, 2) + nutrients + (1|tank),
  data = filter(d2, response == "rhi_mass_g_dw"), iter = 400)
plot(m2)

m3 <- stan_glm(log(value) ~ poly(ph_scaled, 2) + nutrients,
  data = filter(d2, response == "rhi_mass_g_dw"), iter = 400)
plot(m3)

m4 <- stan_glm(log(rhi_mass_g_dw_mean) ~ poly(ph_scaled, 2) + nutrients,
  data = d_log, iter = 400)
plot(m4)

############

m2 <- stan_lmer(log(value) ~ poly(ph_scaled, 2) + nutrients + (1|tank),
  data = filter(d2, response == "shoot_length"), iter = 400)
plot(m2)

m3 <- stan_glm(log(value) ~ poly(ph_scaled, 2) + nutrients,
  data = filter(d2, response == "shoot_length"), iter = 400)
plot(m3)
```

So there are some minor differences. Adding the random intercept for tank does result in much wider confidence intervals on the slopes of interest. There isn't a large difference between using the group-level means versus using all of the data. Let's use all of the data. By not having a random intercept for each tank we are assuming that there isn't tank-level random variation. In other words, there aren't conditions other than the pH and nutrients that are different between the tanks. 

OK, onto the main analysis. 

Here I'm creating a data frame to merge in that describes the type of GLM to fit for each response variable:

```{r}
# TODO use link:
dt <- tribble(
  ~response,                  ~log_transform,  ~family,     ~link,
  "ph_scaled",                NA,              "gaussian",  "identity",
  "nutrients",                NA,              "gaussian",  "identity",
  "algal_mass_g_dw",          TRUE,            "gamma",  "identity",
  "change_idotea_mass_g_fw",  FALSE,           "gaussian",  "identity",
  "change_seahare_mass_g_fw", FALSE,           "gaussian",  "identity",
  "dead_shoots",              FALSE,           "count",     "log",
  "epiphyte_cm_shoot",        TRUE,            "gamma",  "identity",
  "ido_mortality",            TRUE,            "gamma",  "identity",
# "rhi_elong_cm",             TRUE,            "gaussian",  "identity",
# "rhi_mass_g_dw_mean",       TRUE,            "gaussian",  "identity",
  "shoot_length",             TRUE,            "gamma",  "identity",
  "rhi_mass_g_dw",            TRUE,            "gamma",  "identity",
  "sh_grazing",               TRUE,            "gamma",  "identity",
  "sh_mortality",             FALSE,           "count",     "log",
  "sht_g_dw",                 TRUE,            "gamma",  "identity",
# "sht_g_dw_mean",            TRUE,            "gaussian",  "identity",
# "ulva_grazing",             TRUE,            "gaussian",  "identity", # TODO do not include because "epiphyte" was simply Ulva + diatom?
  "epiphyte_grazing",         TRUE,            "gamma",  "identity")

d_long <- gather(d_log, response, value, -ph_scaled, -ph_scaled2, -nutrients, -ph)
# I will remove these rows and add in the newer data that Brent sent me:
d_long <- filter(d_long, !response %in% c("epiphyte_grazing", "diatom_grazing", "sh_grazing"))
d3 <- filter(d3, !response %in% c("ulva_grazing"))
d3$ph_scaled <- scale_ph(d3$ph)
d3$ph_scaled2 <- scale_ph(d3$ph_scaled^2)
d_long <- bind_rows(d_long, d3)

# join in the raw data with multiple values per tank:
d_long <- bind_rows(d_long, select(d2, ph, ph_scaled, ph_scaled2, nutrients, response, value))

d_long <- inner_join(d_long, dt) %>% na.omit() %>% as_data_frame()

d_long <- d_long %>% group_by(response, nutrients, ph) %>% 
  summarise(ph_scaled = ph_scaled[1], ph_scaled2 = ph_scaled2[1],
    value = mean(value), log_transform = log_transform[1],
    family = family[1], link = link[1]) %>% 
  ungroup()
```

That got really confusing. So let's rescale the data here to make sure it is correct. 

```{r}
(sd_ph <- sd(d_long$ph))
(mean_ph <- mean(d_long$ph))
d_long$ph_scaled2 <- d_long$ph_scaled^2
(sd_ph2 <- sd(d_long$ph_scaled2))
d_long$ph_scaled <- scale_ph(d_long$ph)
d_long$ph_scaled2 <- scale_ph2(d_long$ph_scaled2)
assert_that(round(sd(d_long$ph_scaled2), 2) == 0.5)
assert_that(round(sd(d_long$ph_scaled), 2) == 0.5)
assert_that(round(sd(d_long$nutrients), 2) == 0.5)
```

Let's plot the data that we will fit models to:

```{r, fig.width=8.5}
ggplot(d_long, aes(ph_scaled, value, colour = as.factor(nutrients))) + 
  geom_point() +
  facet_wrap(~response, scales = "free_y") +
  theme_gg()
```

Now we can iterate through the various response variables and fit a Bayesian GLM to each. For now, I am log transforming some of the response variables and fitting a linear regression, to others I am fitting a linear regression to the raw data (the change response variables), and I am fitting negative binomial GLMs to the count response variables.

```{r, message=FALSE, results='hide', cache=TRUE}
options(mc.cores = 1L)
fits <- plyr::dlply(d_long, "response", function(x) {
  if (x$log_transform[1])
    f <- log(value) ~ ph_scaled + ph_scaled2 + nutrients
  else
    f <- value ~ ph_scaled + ph_scaled2 + nutrients
    # f <- value ~ poly(ph_scaled, 2) + nutrients
  
  if (x$family[1] == "gaussian")
    fam <- gaussian(link = "identity")
  if (x$family[1] == "gamma")
    fam <- gaussian(link = "identity")
    # fam <- Gamma(link = "log")
  if (x$family[1] == "count")
    fam <- neg_binomial_2(link = "log")
  
  stan_glm(f, data = x, iter = 2000, chains = 4, family = fam,
    prior = normal(0, 1),
    prior_intercept = normal(0, 20),
    prior_aux = student_t(df = 3, 0, 5))
})
saveRDS(fits, file = "data/generated/stan-fits.rds")
```

Let's check each of the models to make sure they converged:

```{r}
check_out <- map(fits, function(x) {
  assert_that(all(x$stan_summary[,"Rhat"] < 1.05))
  assert_that(all(x$stan_summary[,"n_eff"] > 200))
})
```

Now let's extract the samples from the posteriors and make them into a nice data frame to work with:

```{r}
s <- plyr::ldply(fits, function(x) {
  mm <- as.matrix(x)
  as_data_frame(mm[, 2:4])
}) %>% as_data_frame() %>%
  # rename(linear = `poly(ph_scaled, 2)1`, quadratic = `poly(ph_scaled, 2)2`)
  rename(linear = `ph_scaled`, quadratic = `ph_scaled2`)
```

Here I will calculate credible intervals to plot:

```{r}
cis <- gather(s, parameter, value, -response) %>% 
  group_by(response, parameter) %>% 
  summarise(l = quantile(value, 0.05),
    m = quantile(value, 0.5),
    u = quantile(value, 0.95)) %>% 
  ungroup() %>% 
  mutate(parameter = factor(parameter, levels = c("linear", "quadratic", "nutrients")))
```

Now let's plot the coefficients with the credible intervals overlaid:

```{r, fig.height=4, fig.width=6.5}
lims <- c(-3, 3)
cis$l[cis$l < lims[1]] <- lims[1]
cis$u[cis$u > lims[2]] <- lims[2]
cols <- rep(brewer.pal(4, "Blues")[[2]], 2)
g <- gather(s, parameter, sample, -response) %>%
  inner_join(unique(select(d_long, response, log_transform, family))) %>%
  mutate(multiplicative = ifelse(log_transform | family == "count", TRUE, FALSE)) %>%
  mutate(parameter = factor(parameter, levels = c("linear", "quadratic", "nutrients"))) %>%
  ggplot(aes(response, sample)) + 
  geom_hline(yintercept = 0, lty = 2, col = "grey60") +
  geom_violin(fill = cols[1], col = cols[2], adjust = 1.2) +
  coord_flip() +
  facet_wrap(~parameter, scales = "free_x") +
  ylim(lims) +
  theme_gg() +
  ylab("Coefficient (per 2 SD)") + xlab("") +
  geom_point(data = cis, aes(x = response, y = m), col = "grey20", cex = 0.9) +
  geom_segment(data = cis, aes(x = response, y = l, xend = response, yend = u), 
    lwd = 0.4, col = "grey20")
g
ggsave("figs/gg-pars.pdf", width = 7, height = 4)
```

Next we will plot the model fits on top of the data. First we will need to create a data set with smaller increments on the predictors so that the plots are smooth:

```{r}
# TODO:
# newdata <- expand.grid(ph_scaled = seq(min(d$ph_scaled), max(d$ph_scaled), length.out = 200), 
#   nutrients = c(0, 1))
# newdata <- data.frame(newdata, linear = poly(newdata$ph_scaled, 2)[,1], 
# quad = poly(newdata$ph_scaled, 2)[,2], ph = newdata$ph_scaled * 2 * sd(d$ph) + mean(d$ph))

newdata <- unique(select(d_long, ph_scaled, ph_scaled2, ph, nutrients))

newdata <- data.frame(newdata, linear = newdata$ph_scaled, quad = newdata$ph_scaled2)

N <- 250
newdata <- group_by(newdata, nutrients) %>%
  do({
    data.frame(ph_scaled = spline(.$ph_scaled, n = N)$y,
      ph = spline(.$ph, n = N)$y,
      linear = spline(.$linear, n = N)$y,
      quad = spline(.$quad, n = N)$y) # TODO use spline approx?
  })
```

Now make the predictions:

```{r}
p <- plyr::ldply(fits, function(x) {
  mm <- as.matrix(x)
  b <- as_data_frame(mm) %>% rename(
    b0 = `(Intercept)`,
    b1 = `ph_scaled`,
    b2 = `ph_scaled2`)
  pp <- apply(newdata, 1, function(y) {
    b$b0 + b$b1 * y["linear"] + b$b2 * y["quad"] + b$nutrients * y["nutrients"]
  })
  l <- apply(pp, 2, quantile, probs = 0.1)
  u <- apply(pp, 2, quantile, probs = 0.9)
  med <- apply(pp, 2, quantile, probs = 0.5)
  data.frame(l, med, u, newdata)
}) %>% as_data_frame()

pp <- inner_join(p, unique(select(d_long, response, log_transform, family)))
pp <- pp %>% group_by(response) %>% 
  mutate(med = ifelse(log_transform | family == "count", exp(med), med)) %>% 
  mutate(l = ifelse(log_transform | family == "count", exp(l), l)) %>% 
  mutate(u = ifelse(log_transform | family == "count", exp(u), u))
```

And finally make the plot:

```{r, fig.width=8.5}
cols <- c(brewer.pal(4, "Greys")[[3]], brewer.pal(4, "Blues")[[3]])
g <- ggplot(d_long, aes(ph, value, colour = as.factor(nutrients))) + 
  geom_point(alpha = 0.3) +
  facet_wrap(~response, scales = "free_y") +
  geom_line(data = pp, aes(ph, y = med), lwd = 1) +
  geom_ribbon(data = pp, aes(ph, ymax = u, ymin = l, fill = as.factor(nutrients)), 
    alpha = 0.15, inherit.aes = FALSE) +
  theme_gg() +
  labs(colour = "Nutrients", fill = "Nutrients", y = "Response value", x = "pH") +
  scale_color_manual(values = cols) + scale_fill_manual(values = cols)
g
ggsave("figs/gg-fits.pdf", width = 10, height = 6)
```
