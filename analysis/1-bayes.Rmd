# Bayesian analysis of seagrass stressors 

```{r, echo=FALSE}
library(knitr)
opts_knit$set(root.dir = "..") 
```

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r, message=FALSE}
library(tidyverse)
library(rstanarm)
library(RColorBrewer)
library(assertthat)
```

We'll create this folder in case it isn't already there. 

```{r}
dir.create("figs", showWarnings = FALSE)
dir.create("data/generated", showWarnings = FALSE)
```

A custom theme for ggplot:

```{r}
theme_gg <- function(base_size = 11, base_family = "") {
  half_line <- base_size/2
  theme_light() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      axis.ticks.length = grid::unit(half_line/2.2, "pt"),
      strip.background = element_rect(fill = NA, colour = NA),
      strip.text.x = element_text(colour = "grey20"),
      axis.text = element_text(colour = "grey30"),
      axis.title = element_text(colour = "grey30"),
      legend.title = element_text(colour = "grey30", size = rel(0.9)),
      panel.border = element_rect(fill = NA, colour = "grey70", size = 1),
      legend.key.size = unit(0.8, "lines"),
      legend.text = element_text(size = rel(0.7), colour = "grey30"),
      legend.key = element_rect(colour = NA, fill = NA),
      legend.background = element_rect(fill = NA)
    )
}
```

Let's read in the data:

```{r}
d1 <- read_csv("data/mesocosm_data_1.csv", na = c("NA", "na"))
d2 <- read_csv("data/mesocosm_data_2.csv", na = c("NA", "na"))
d3 <- read_csv("data/mesocosm_data_3.csv", na = c("NA", "na"))
labels <- read_csv("data/mesocosm_figure_labels.csv") %>% 
  rename(response = label_data, label = label_pub, 
    figure_panel = order, notes = Notes) %>% 
  select(-notes)
names(d1) <- tolower(names(d1))
names(d2) <- tolower(names(d2))
names(d3) <- tolower(names(d3))

sd_ph <- sd(d3$ph)
mean_ph <- mean(d3$ph)
scale_ph <- function(x) (x - mean_ph) / (2 * sd_ph)

d1 <- d1 %>% select(-rep) %>% 
  gather(response, value, -ph, -nutrients)
d2 <- d2 %>% 
  gather(response, value, -ph, -nutrients)
d3 <- d3 %>% select(-barrel) %>% 
  gather(response, value, -ph, -nutrients)

d <- bind_rows(d1, d2) %>% bind_rows(d3)
d <- mutate(d, nutrients_text = nutrients,
  nutrients = as.numeric(as.factor(nutrients)) - 1)
assert_that(identical(unique(d$nutrients), c(0, 1)))

d <- left_join(d, labels)
assert_that(all(!is.na(d$label)))
```

We need to subtract 20 from each shoot elongation response:

```{r}
d$value[d$response == "shoot_length"] <- d$value[d$response == "shoot_length"] - 20
d$value[d$response == "change_plant_mass_g_fw"] <- d$value[d$response == "change_plant_mass_g_fw"]/10
d$value[d$response == "shoot_length"] <- d$value[d$response == "shoot_length"]/10
d <- filter(d, !is.na(value))
```

TODO: `ulva_grazing` is zero for all cases of no nutrients

```{r}
ggplot(d, aes(ph, value, colour = nutrients_text)) + 
  geom_point(position = position_jitter(width = 0.03), alpha = 0.5) +
  facet_wrap(~response, scales = "free_y")
```

```{r, eval=FALSE, echo=FALSE}
all_whole_numbers <- function(x) {
  identical(x, round(x))
}

group_by(d, response) %>% 
  summarize(minimum_value = min(value), counts = all_whole_numbers(value)) %>% 
  filter(minimum_value == 0, !counts)

group_by(d, response) %>% 
  summarize(minimum_value = min(value), counts = all_whole_numbers(value)) %>% 
  filter(counts)

group_by(d, response) %>% 
  summarize(minimum_value = min(value), counts = all_whole_numbers(value)) %>% 
  filter(minimum_value < 0)
```

Here I'm creating a data frame to merge in that describes the type of GLM to fit for each response variable:

```{r}
# link not used!
dt <- tribble(
  ~response,                  ~log_transform,  ~family,     ~link,
  "algal_mass_g_dw",          TRUE,            "gaussian",  "identity",
  "change_idotea_mass_g_fw",  FALSE,           "gaussian",  "identity",
  "change_plant_mass_g_fw",   FALSE,           "gaussian",  "identity",
  "change_seahare_mass_g_fw", FALSE,           "gaussian",  "identity",
  "dead_shoots",              FALSE,           "count",     "log",
  "diatom_grazing",           TRUE,            "gaussian",  "identity",
  "epiphyte_cm_shoot",        TRUE,            "gaussian",  "identity",
  "ido_mortality",            FALSE,           "count",     "log",
  "rhi_elong_cm",             FALSE,           "gaussian",  "identity",
  "rhi_mass_g_dw",            TRUE,            "gaussian",  "identity",
  "sh_grazing",               TRUE,            "gaussian",  "identity",
  "sh_mortality",             FALSE,           "count",     "log",
  "shoot_length",             FALSE,           "gaussian",  "identity",
  "sht_g_dw",                 TRUE,            "gaussian",  "identity",
  "ulva_grazing",             TRUE,            "gaussian",  "identity")


d_long <- left_join(d, dt)
meta <- unique(select(d_long, response, log_transform, family))
save(meta, file = "data/meta.rda")
```

Let's work with orthogonal polynomials:

```{r}
d_long$ph_scaled <- d$ph
d_long <- d_long %>% group_by(response) %>%
  mutate(
    ph_scaled = poly(ph, 2)[,1],
    ph_scaled2 = poly(ph, 2)[,2]) %>%
  ungroup()

d_long <- group_by(d_long, response) %>% 
  mutate(value = ifelse(min(value) == 0 & log_transform, value + 0.1, value))
```

Let's plot the data that we will fit models to:

```{r, fig.width=8.5}
ggplot(d_long, aes(ph_scaled, value, colour = nutrients_text)) + 
  geom_point() +
  facet_wrap(~response, scales = "free_y") +
  theme_gg()
```

Now we can iterate through the various response variables and fit a Bayesian GLM to each. For now, I am log transforming some of the response variables and fitting a linear regression, to others I am fitting a linear regression to the raw data (the change response variables), and I am fitting negative binomial GLMs to the count response variables.

```{r, message=FALSE, results='hide', cache=FALSE}
options(mc.cores = 1L)
fits <- plyr::dlply(d_long, "response", function(x) {
  print(unique(x$response))
  if (x$log_transform[1]) {
    f <- log(value) ~ ph_scaled + ph_scaled2 + nutrients
  } else
    f <- value ~ ph_scaled + ph_scaled2 + nutrients
  
  if (x$family[1] == "gaussian") {
    fam <- gaussian(link = "identity")
    prior_aux <- student_t(df = 3, 0, 5)
  }
#  if (x$family[1] == "gamma")
#    fam <- gaussian(link = "identity")
    # fam <- Gamma(link = "log")
  if (x$family[1] == "count") {
    fam <- neg_binomial_2(link = "log")
    prior_aux <- student_t(df = 3, 0, 20)
  }
  
  stan_glm(f, data = x, iter = 2000, chains = 4, family = fam,
    prior = normal(0, 1),
    prior_intercept = normal(0, 10),
    prior_aux = prior_aux)
})
saveRDS(fits, file = "data/generated/stan-fits.rds")
```

Let's check each of the models to make sure they converged:

```{r}
check_out <- map(fits, function(x) {
  assert_that(all(x$stan_summary[,"Rhat"] < 1.05))
  assert_that(all(x$stan_summary[,"n_eff"] > 200))
})
```

Now let's extract the samples from the posteriors and make them into a nice data frame to work with:

```{r}
s <- plyr::ldply(fits, function(x) {
  mm <- as.matrix(x)
  as_data_frame(mm[, 2:4])
}) %>% as_data_frame() %>%
  rename(linear = `ph_scaled`, quadratic = `ph_scaled2`)
```

```{r}
fits
```

Here I will calculate credible intervals to plot:

```{r}
cis <- gather(s, parameter, value, -response) %>% 
  group_by(response, parameter) %>% 
  summarise(l = quantile(value, 0.025),
    m = quantile(value, 0.5),
    u = quantile(value, 0.975)) %>% 
  ungroup() %>% 
  mutate(parameter = factor(parameter, levels = c("linear", "quadratic", "nutrients"))) %>% 
  left_join(labels)
```

Now let's plot the coefficients with the credible intervals overlaid:

```{r, fig.height=4, fig.width=6.5}
lims <- c(-6, 6)
cis$l[cis$l < lims[1]] <- lims[1]
cis$u[cis$u > lims[2]] <- lims[2]
cis <- mutate(cis, parameter = factor(parameter, levels = c("linear", "quadratic", "nutrients"),
    labels = c("Linear - pH", "Quadratic - pH", "Nutrients")))
cis$label <- sub("\\([a-zA-Z0-9 /%]*\\)", "", cis$label)
cis$label <- sub(" $", "", cis$label)
cis$label <- sub("\\\\n", "", cis$label)
cis <- mutate(cis, label_ordered = paste(label, toupper(figure_panel), sep = " - "))
cis <- mutate(cis, label_ordered = reorder(label_ordered, -as.numeric(as.factor(figure_panel))))
```

```{r}
cols <- rep(brewer.pal(4, "Blues")[[2]], 2)
g <- gather(s, parameter, sample, -response) %>%
  inner_join(unique(select(d_long, response, log_transform, family, label, figure_panel))) %>%
  # mutate(multiplicative = ifelse(log_transform | family == "count", TRUE, FALSE)) %>%
  mutate(parameter = factor(parameter, levels = c("linear", "quadratic", "nutrients"),
    labels = c("Linear - pH", "Quadratic - pH", "Nutrients"))) %>%
  mutate(label = sub("\\([a-zA-Z0-9 /%]*\\)", "", label)) %>% 
  mutate(label = sub(" $", "", label)) %>% 
  mutate(label = sub("\\\\n", "", label)) %>% 
  mutate(label_ordered = paste(label, toupper(figure_panel), sep = " - ")) %>% 
  mutate(label_ordered = reorder(label_ordered, -as.numeric(as.factor(figure_panel)))) %>% 
  ggplot(aes(x = label_ordered, sample)) + 
  geom_hline(yintercept = 0, lty = 2, col = "grey60") +
  geom_violin(fill = cols[1], col = cols[2], adjust = 1.2) +
  coord_flip() +
  facet_wrap(~parameter, scales = "free_x") +
  ylim(lims) +
  theme_gg() +
  ylab("Coefficient") + xlab("") +
  geom_point(data = cis, aes(x = label_ordered, y = m), col = "grey20", cex = 0.9) +
  geom_segment(data = cis, aes(x = label_ordered, y = l, xend = label_ordered, yend = u),
    lwd = 0.4, col = "grey20") +
  geom_vline(xintercept = c(4.5, 8.5, 12.5), col = "grey60", lty = 3)
g
ggsave("figs/gg-pars.pdf", width = 7, height = 4)
```

Next we will plot the model fits on top of the data. First we will need to create a data set with smaller increments on the predictors so that the plots are smooth:

```{r}
N <- 200
newdata <- group_by(d_long, response) %>%
  do({
    data.frame(ph_scaled = predict(poly(.$ph, 2), seq(min(.$ph), max(.$ph), length.out = N))[,1],
      ph = seq(min(.$ph), max(.$ph), length.out = N),
      ph_scaled2 = predict(poly(.$ph, 2), seq(min(.$ph), max(.$ph), length.out = N))[,2])
  })
newdata <- bind_rows(data.frame(newdata, nutrients = 0), data.frame(newdata, nutrients = 1))
```

Now make the predictions:

```{r}
# ii <<- 0
# p <- plyr::ldply(fits, function(x) {
#   ii <<- ii + 1
#   mm <- as.matrix(x)
#   b <- as_data_frame(mm) %>% rename(
#     b0 = `(Intercept)`,
#     b1 = `ph_scaled`,
#     b2 = `ph_scaled2`)
#   newdata_this_response <- as.data.frame(filter(newdata, response == names(fits)[[ii]]))
#   pp <- apply(newdata_this_response, 1, function(y) {
#     b$b0 + b$b1 * as.numeric(y[["ph_scaled"]]) +
#       b$b2 * as.numeric(y[["ph_scaled2"]]) +
#       b$nutrients * as.numeric(y[["nutrients"]])
#   })
#   l <- apply(pp, 2, quantile, probs = 0.1)
#   u <- apply(pp, 2, quantile, probs = 0.9)
#   med <- apply(pp, 2, quantile, probs = 0.5)
#   data.frame(l, med, u, newdata_this_response)
# }) %>% as_data_frame()

ii <<- 0
p <- plyr::ldply(fits, function(x) {
  ii <<- ii + 1
  newdata_this_response <- as.data.frame(filter(newdata, response == names(fits)[[ii]]))
  pp <- predict(x, newdata = newdata_this_response, se.fit = TRUE)
  l <- pp$fit - qnorm(.9) * pp$se.fit
  u <- pp$fit + qnorm(.9) * pp$se.fit # 80% CI
  med <- pp$fit
  data.frame(l, med, u, newdata_this_response)
}) %>% as_data_frame()

pp <- inner_join(p, unique(select(d_long, response, log_transform, family)))
pp <- pp %>% group_by(response) %>%
  mutate(med = ifelse(log_transform | family == "count", exp(med), med)) %>%
  mutate(l = ifelse(log_transform | family == "count", exp(l), l)) %>%
  mutate(u = ifelse(log_transform | family == "count", exp(u), u)) %>%
  left_join(labels)
```

And finally make the plot:

```{r, fig.width=8.5}
d_long_plot <- d_long %>% group_by(response, nutrients, ph) %>%
  summarise(ph_scaled = ph_scaled[1], ph_scaled2 = ph_scaled2[1],
    value = ifelse(log_transform[1], exp(mean(log(value))), mean(value)),
    log_transform = log_transform[1],
    family = family[1], link = link[1]) %>%
  ungroup() %>%
  left_join(labels)

# d_long_plot <- d_long

cols <- c(brewer.pal(4, "Greys")[[3]], brewer.pal(4, "Blues")[[3]])
g <- ggplot(d_long_plot, aes(ph, value, colour = as.factor(nutrients))) + 
  geom_point(alpha = 0.3) +
  facet_wrap(~label, scales = "free_y") +
  geom_line(data = pp, aes(ph, y = med), lwd = 1) +
  geom_ribbon(data = pp, aes(ph, ymax = u, ymin = l, fill = as.factor(nutrients)), 
    alpha = 0.15, inherit.aes = FALSE) +
  theme_gg() +
  labs(colour = "Nutrients", fill = "Nutrients", y = "Response value", x = "pH") +
  scale_color_manual(values = cols) + scale_fill_manual(values = cols)
g
ggsave("figs/gg-fits.pdf", width = 10, height = 6)
```

# Separate figures for groups of responses 

```{r}
pp <- mutate(pp, nutrients_text = ifelse(nutrients == 0, "No Nutrients", "Nutrients added"))
d_long_plot <- mutate(d_long_plot, nutrients_text = ifelse(nutrients == 0, "No Nutrients", "Nutrients added"))

pp$label_wrap = stringr::str_wrap(pp$label, width = 99)
d_long_plot$label_wrap = stringr::str_wrap(d_long_plot$label, width = 99)

pp$label_wrap <- sub("\\\\n","\n", pp$label_wrap)
d_long_plot$label_wrap <- sub("\\\\n","\n", d_long_plot$label_wrap)

pp <- mutate(pp, 
  label_ordered = reorder(label_wrap, as.numeric(as.factor(figure_panel))))
d_long_plot <- mutate(d_long_plot, 
  label_ordered = reorder(label_wrap, as.numeric(as.factor(figure_panel))))

cols <- c(brewer.pal(4, "Greys")[[3]], brewer.pal(4, "Blues")[[3]])

plot_predictions <- function(figure_id, legend_position = c(.85, .96)) {

    dat <- filter(d_long_plot, substr(figure_panel, 0, 1) == figure_id)
  pp_data <-filter(pp, substr(figure_panel, 0, 1) == figure_id)
  
  max_ci <- group_by(pp, response) %>% 
    summarize(max_ci = max(u), min_ci = min(u))
    
  let <- dat %>% left_join(max_ci) %>% 
    group_by(response) %>%
    summarize(label_ordered = label_ordered[1], 
      x = min(ph) + 0.02, 
      range = diff(range(c(value, max_ci, min_ci))), 
      y = max(c(value, max_ci)) - range * 0.04) %>% 
    arrange(label_ordered) %>%
    mutate(panel = LETTERS[1:n()])
  
  g <- ggplot(dat, aes_string("ph", "value", colour = "nutrients_text")) + 
    geom_point(alpha = 0.45, aes(shape = nutrients_text)) +
    facet_wrap(~label_ordered, scales = "free_y") +
    geom_line(data = pp_data, aes_string("ph", y = "med"), lwd = 1) +
    geom_ribbon(data = pp_data, aes_string("ph", ymax = "u", ymin = "l", 
      fill = "nutrients_text"), 
      alpha = 0.15, inherit.aes = FALSE) +
    theme_gg() +
    labs(colour = "Nutrients", fill = "Nutrients", y = "Response value", x = "pH") +
    scale_color_manual(values = cols) + scale_fill_manual(values = cols) +
    theme(legend.position = legend_position) +
    labs(color = "", fill = "", shape = "") +
    geom_text(data = let, aes(x = x, y = y, label = panel), inherit.aes = FALSE) +
    scale_shape_manual(values = c(19, 19))
  g
}
plot_predictions("2", legend_position = c(.87, .93))
ggsave("figs/fig-2.pdf", width = 6.9, height = 2.3)
plot_predictions("3")
ggsave("figs/fig-3.pdf", width = 4.5, height = 3.8)
plot_predictions("4")
ggsave("figs/fig-4.pdf", width = 4.5, height = 3.8)
plot_predictions("S")
ggsave("figs/fig-S1.pdf", width = 4.5, height = 3.8)
```

